---

# 📚 SQLD 합격 보증 총정리 (심화 이론 + 실전 예시판)

## 🏛️ 제1과목: 데이터 모델링의 이해

### 01. 데이터 모델링 기초 및 3단계

* **단계별 예시:**
1. **개념적 모델링:** "우리 회사는 **고객**이 **상품**을 **주문**한다"라는 큰 틀을 정의하고 ERD의 뼈대를 그림.
2. **논리적 모델링:** "주문 테이블에 고객번호, 상품번호를 넣고 **정규화**를 통해 중복을 제거하자"라고 설계함. (특정 DB 제품 결정 전)
3. **물리적 모델링:** "Oracle DB를 쓰니 인덱스를 생성하고, 조회 성능을 위해 테이블을 **반정규화**하자."



### 02. 엔터티 (Entity)

* **발생 시점별 분류 예시:**
* **기본 엔터티:** 고객, 상품 (스스로 존재)
* **중심 엔터티:** 주문 (고객과 상품이 있어야 발생, 데이터 양이 많음)
* **행위 엔터티:** 주문취소이력, 접속로그 (두 엔터티 간의 활동으로 생성)



### 03. 속성 (Attribute)

* **특성별 분류 예시:**
* **기본 속성:** 이름, 나이
* **설계 속성:** 고객코드 (업무를 위해 인위적으로 만든 값)
* **파생 속성:** 총주문금액, 평균점수 (다른 값을 계산해서 얻은 값)



### 04. 관계 (Relationship)

* **식별/비식별 예시:**
* **식별 관계:** '게시글'과 '첨부파일'. 게시글이 삭제되면 첨부파일도 의미가 없으므로 부모 키를 자기 주식별자로 씀.
* **비식별 관계:** '부서'와 '사원'. 사원은 부서에 소속되지만, 부서번호가 사원의 주 식별자는 아님(사원번호가 따로 존재).



### 05. 정규화 (Normalization)

* **단계별 상세:**
* **1NF (원자성):** 한 칸에 전화번호가 2개 들어있으면 안 됨 → 행을 나눔.
* **2NF (부분 함수 종속):** 복합키(학번+과목코드)에서 '학생이름'은 학번에만 종속됨 → 학생 테이블로 분리.
* **3NF (이행 함수 종속):** 학번→학과코드→학과이름일 때, 학과이름은 학과코드에 종속됨 → 학과 테이블로 분리.



---

## 💻 제2과목: SQL 기본 및 활용 (심화 보강)

### 01. SQL 종류 및 트랜잭션

* **심화 포인트:**
* **TRUNCATE vs DELETE:** `DELETE`는 삭제 데이터를 로그에 쌓아 느리지만 롤백이 가능하고, `TRUNCATE`는 데이터 페이지를 통째로 비워 매우 빠르나 롤백이 불가함.
* **SELECT 실행 순서 실전:** `SELECT 사원명 AS 이름 FROM 사원 WHERE 이름 = '홍길동';` -> **에러 발생!** (WHERE가 SELECT보다 먼저 실행되므로 '이름'이라는 별칭을 인식 못 함)



### 02. 연산자 및 NULL 처리

* **NULL 계산 예시:**
* `COL1`의 값이 `(10, 20, NULL)` 일 때:
* `SELECT SUM(COL1)` → 30
* `SELECT AVG(COL1)` → 15 (30 / 2개 행)
* `SELECT COUNT(*)` → 3 (NULL 포함 전체)
* `SELECT COUNT(COL1)` → 2 (NULL 제외)



### 03. 단일행 및 집계 함수

* **문자열 함수:** `SUBSTR('ABCDE', 2, 3)` → 'BCD' (2번째부터 3글자)
* **NULL 처리 함수:**
* `NVL(A, 0)`: A가 NULL이면 0.
* `NULLIF(A, B)`: A와 B가 같으면 NULL, 다르면 A. (예: `NULLIF(10, 10)` -> NULL)
* `COALESCE(A, B, C)`: 첫 번째로 NULL이 아닌 값 반환.



### 04. 그룹 함수 (심화 추가)

* **ROLLUP (A, B):** (A, B) 합계, (A) 소계, 전체 합계.
* **CUBE (A, B):** (A, B) 합계, (A) 소계, **(B) 소계**, 전체 합계. (모든 조합)
* **GROUPING SETS (A, B):** (A) 합계, (B) 합계만 출력. (계층 구조 없음)

### 05. 조인 (JOIN) 원리

* **NL Join (Nested Loop):** * "중첩 반복문" 방식. 소량 데이터 조인 시 유리.
* 선행 테이블(Driving)의 인덱스가 조인 성능을 좌우함.


* **Hash Join:** * 해시 테이블을 메모리에 구축. 대용량 데이터 조인 시 유리.
* **동등 조인(=)**에서만 사용 가능함.


* **Sort Merge Join:** * 두 테이블을 정렬한 뒤 병합. 인덱스가 없을 때 사용함.

### 06. 서브쿼리 (Subquery)

* **스칼라 서브쿼리:** `SELECT 사원명, (SELECT 부서명 FROM 부서 WHERE 부서ID = 사원.부서ID) FROM 사원;`
* **인라인 뷰:** `SELECT * FROM (SELECT * FROM 사원 WHERE 급여 > 3000) A;`
* **ANY / ALL 연산자:**
* `> ANY (10, 20)` : 최솟값(10)보다 크면 참.
* `> ALL (10, 20)` : 최댓값(20)보다 커야 참.



### 07. 윈도우 함수 (심화 추가)

* **순위 함수:**
* `RANK`: 1, 2, 2, 4
* `DENSE_RANK`: 1, 2, 2, 3
* `ROW_NUMBER`: 1, 2, 3, 4


* **행간 이동:**
* `LAG(급여, 1)`: 바로 이전 행의 급여를 가져옴.
* `LEAD(급여, 1)`: 바로 다음 행의 급여를 가져옴.



### 08. 계층형 질의

* **방향 확인:**
* `CONNECT BY PRIOR 자식 = 부모`: 부모에서 자식으로 (순방향/하향식)
* `CONNECT BY PRIOR 부모 = 자식`: 자식에서 부모로 (역방향/상향식)


* **가상 컬럼:** `LEVEL` (루트 노드는 1, 아래로 갈수록 증가)

---

## 🎯 각 과목 실전 대비 고난도 문제

### [1과목]

**Q: 다음 중 2차 정규화(2NF)를 수행하여 분리해야 하는 케이스는?**

1. 속성이 원자성을 가지지 않을 때
2. **주식별자가 (ID, 순번)인 복합키인데, 일반 속성이 ID에만 종속될 때**
3. 일반 속성끼리 종속 관계가 존재할 때
4. 결정자가 후보키가 아닐 때

* **해설:** 복합키 중 일부에만 종속되는 '부분 함수 종속' 제거가 2차 정규화입니다.

### [2과목]

**Q: 다음 SQL의 실행 결과로 올바른 것은?**
`Table: T1 (ColA: 1, 2, 2, 3)`
`SELECT DENSE_RANK() OVER (ORDER BY ColA) FROM T1;`

* **정답:** 1, 2, 2, 3
* **해설:** RANK였다면 1, 2, 2, 4였겠지만 DENSE_RANK는 순위를 건너뛰지 않습니다.

**Q: 부모 테이블의 행을 삭제할 때 자식 테이블의 관련 행도 자동으로 삭제되도록 설정하는 제약조건 옵션은?**

* **정답:** `ON DELETE CASCADE`

---
